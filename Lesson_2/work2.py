# ======================== 1. РАБОТА СО СПИСКАМИ: ========================================
print("======================== 1. РАБОТА СО СПИСКАМИ: ========================================")
list_1 = []  # Создание пустого списка
print(list_1)  # Вывод: []
print()  # Отступ между строками

list_2 = list()  # Создание пустого списка
print(list_2)   # Вывод: []
print()

list_3 = [7, 9, 11, 13, 15, 17]
print(list_3)       # Вывод: [7, 9, 11, 13, 15, 17]
print(*list_3)      # Вывод: 7 9 11 13 15 17
print()

## Хотим вывести первый элемент списка:
list_1 = [7, 9, 11, 13, 15, 17]
print(list_1[0])  # Вывод: 7
print(list_1[-1])  # Вывод: 17
print(list_1[-2])  # Вывод: 15
print()

## Чтобы узнать КОЛИЧЕСТВО ЭЛЕМЕНТОВ в списке необходимо использовать функцию ~~len(имя_списка)~~:
list_1 = [7, 9, 11, 13, 15, 17]
print(len(list_1))  # Вывод: 6
print()

## ДОБАВИТЬ В КОНЕЦ СПИСКА новую ПЕРЕМЕННУЮ для этого нужно
## воспользоваться функцией: .append(n)
list_1 = [7, 9, 17]
list_1.append(8)
print(list_1)  # Вывод: [7, 9, 17, 8]
print()

## ЗАПОЛНЕНИЕ СПИСКА непосредственно во время работы программы:
list_1 = list()  # создание пустого списка
for i in range(5):  # цикл выполнится 5 раз
    n = int(input())  # пользователь вводит целое число
    list_1.append(n)  # сохранение элемента в конец списка
# Вывод:
# 1-я итерация цикла(повторение 1): n = 12, list_1 = [12]
# 2-я итерация цикла(повторение 2): n = 7, list_1 = [12, 7]
# 3-я итерация цикла(повторение 3): n = -1, list_1 = [12, 7, -1]
# 4-я итерация цикла(повторение 4): n = 21, list_1 = [12, 7, -1, 21]
# 5-я итерация цикла(повторение 5): n = 0, list_1 = [12, 7, -1, 21, 0]
print(list_1)  # Вывод: [12, 7, -1, 21, 0]
print()

## Для взаимодействия с большим списком используют цикл for:
list_1 = [12, 7, -1, 21, 0]
for i in range(len(list_1)):
    print(list_1[i])  # вывод каждого элемента списка
# Вывод:
# 1-я итерация цикла(повторение 1): list_1[0] = 12
# 2-я итерация цикла(повторение 2): list_1[1] = 7
# 3-я итерация цикла(повторение 3): list_1[2] = -1
# 4-я итерация цикла(повторение 4): list_1[3] = 21
# 5-я итерация цикла(повторение 5): list_1[4] = 0
print()

# ======================= 2. ОСНОВНЫЕ ДЕЙСТВИЯ СО СПИСКАМИ: =============================
print("======================= 2. ОСНОВНЫЕ ДЕЙСТВИЯ СО СПИСКАМИ: =============================")

    ## 1. Удаление последнего элемента списка.
        ### Метод ~~ pop ~~ УДАЛЯЕТ ПОСЛЕДНИЙ ЭЛЕМЕНТ из списка:
list_1 = [12, 7, -1, 21, 0]
print(list_1.pop())  # Удаляем: 0
print(list_1)        # Вывод: [12, 7, -1, 21]
print(list_1.pop())  # Удаляем: 21
print(list_1)        # Вывод: [12, 7, -1]
print(list_1.pop())  # Удаляем: -1
print(list_1)        # Вывод: [12, 7]
print()

    ## 2. Удаление КОНКРЕТНОГО элемента из списка.
        ### Надо указать значение индекса в качестве аргумента функции ~~ pop ~~:
list_1 = [12, 7, -1, 21, 0]
print(list_1.pop(0))  # Удаляем элемент с индексом [0]: 12
print(list_1)         # Вывод: [7, -1, 21, 0]
print()

    ## 3. ДОБАВЛЕНИЕ ЭЛЕМЕНТА на нужную позицию.
        ### Функция ~~ insert ~~ — указание индекса (позиции) и значения.
list_1 = [12, 7, -1, 21, 0]
print(list_1.insert(2, 11)) 
# где 2 - индекс элемента, 11 - значение для этой позиции. 
# Остальные переменные сдвигаются по позиции на +1
print(list_1)  # Вывод: [12, 7, 11, -1, 21, 0]
print()

# ======================= 3. СРЕЗЫ СПИСКОВ: =============================
print("======================= 3. СРЕЗЫ СПИСКОВ: =============================")

# P.S. Отрицательное число в индексе — счёт с конца списка

list_1 = [5, 17, 8, 16, 2, 3, 22, 16, 0, 4]
print(list_1[0])                # Вывод: 5
print(list_1[1])                # Вывод: 17
print(list_1[len(list_1)-1])    # Вывод: 4
print(list_1[-1])               # Вывод: 4
print(list_1[-5])               # Вывод: 3
print(list_1[:])                # Вывод: [5, 17, 8, 16, 22, 3, 6, 16, 0, 4]
print(list_1[:2])               # Вывод: [5, 17] 
print(list_1[len(list_1)-2:])   # Вывод: [0, 4] - последние 2 элемента, т.е. от размера нашего списка отнимем 2, а после знака : ничего не укажем
print(list_1[2:9])              # Вывод: [8, 16, 2, 3, 22, 16, 0] - вывести список в интервале от элемента с индексом 2 включительно до элемента с индексом 9  не включительно
print(list_1[6:-18])            # Вывод: []
print(list_1[0:len(list_1):6])  # Вывод: [5, 22] - вывести список от начала до конца с шагом = 6
print(list_1[::6])              # Вывод: [5, 22]
print()

# ======================= 4. КОРТЕЖИ: =============================
print("======================= 4. КОРТЕЖИ: =============================")

# Кортеж занимает меньше места в памяти и работают быстрее, 
# по сравнению со списками (для защиты каких-либо данных)

t = ()  # создание пустого кортежа
print(type(t))      # Вывод типа переменной: class <'tuple'>

t = (1, )
print(type(t))      # Вывод типа переменной: class <'tuple'>

t = (1)
print(type(t))      # Вывод типа переменной t: class <'int'>

t = (28, 9, 1990, ) # В конце списка д.б. запятая, тогда будет кортеж
print(type(t))      # Вывод типа переменной: class <'tuple'>

colors = ['red', 'green', 'blue']
print(colors)       # Вывод: ['red', 'green', 'blue']
t = tuple(colors)
print(t)            # Вывод: ('red', 'green', 'blue')

t = tuple(['red', 'green', 'blue'])
print(t[0])         # Вывод: red
print(t[2])         # Вывод: blue
for e in t: # либо можем записать: for e in range(len[t]): print(t[i]) - результат будет тот же
    print(e)            # Вывод: red green blue
t[0] = 'black'  # TypeError: 'tuple' object does not support(нельзя изменять кортеж), 
                # т.к. 'tuple' - не поддерживает преобразование аргументов
print()

    ## Можно распаковать кортеж в независимые переменные:
t = tuple(['red', 'green', 'blue'])
red, green, blue = t
print('r:{} g:{} b:{}'.format(red, green, blue))  # Вывод: r:red g:green b:blue
print()

# ======================= 5. СЛОВАРИ: =============================
print("======================= 5. СЛОВАРИ: =============================")
# P.S. В списках в качестве ключа используется индекс элемента. 
#      В словаре для определения элемента используется значение ключа (строка, число).
#~1~
dictionary = {} # создали пустой словарь
d = dict() # другой способ записи создания пустого словаря

#~2~
dictionary = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
print(dictionary)           # Вывод: {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}

#~3~
dictionary[123] = {123456}  # Дополнили существующий словарь новыми данными
print(dictionary)           # Вывод: {'up':'↑', 'left':'←', 'down':'↓', 'right':'→', 123:{123456} } - теперь словарь состоит из строк и цифр

#~4~ 
# Обращаемся к элементам словаря по ключам, типы ключей могут отличаться
print(dictionary['left'])   # Вывод: ←
print(dictionary[123])     # Вывод: {123456}
print(dictionary['type'])   # Вывод: KeyError: 'type' - такого ключа в словаре не существует!!!

#~5~ 
# Заменяем элемент словаря
dictionary['left'] = '⇐'
print(dictionary['left'])   # Вывод: ⇐

#~6~
#Хотим удалить элемент из словаря:
del dictionary['left'] # удаление элемента

#~7~
 print(dictionary.items())  #Выводится список: dict_items([(up':'↑'), ('left':'←'), ('down':'↓'), ('right':'→'), (123:{123456})])
                            # где каждый элемент является кортежем из двух значений:
                            # знач.1 - ключ, знач.2 - элемент словаря

for item in dictionary: # for (k,v) in dictionary.items():
    print(item) # выводиться будут только название ключей: up, down, right
    print('{}: {}'.format(item, dictionary[item]))
# Вывод:
#       up: ↑
#       down: ↓
#       right: →
print()

# ======================= 6. МНОЖЕСТВА: =============================
print("======================= 6. МНОЖЕСТВА: =============================")
# P.S. Множества содержат в себе уникальные элементы (=> НЕ ПОВТОРЯЮТСЯ), не обязательно упорядоченные.

q = set() # Создание пустого множества

colors = {'red', 'green', 'blue'}
print(colors)           # Вывод: {'red', 'green', 'blue'}

colors.add('red')
print(colors)           # Вывод: {'red', 'green', 'blue'}

colors.add('gray')
print(colors)           # Вывод: {'red', 'green', 'blue','gray'}

colors.remove('red')
print(colors)           # Вывод: {'green', 'blue','gray'}

# Хотим удалить уже имеющееся множество:
colors.remove('red')    # Вывод: KeyError: 'red'
# Хотим проверить множество на наличие элемента:
colors.discard('red')   # Если такое множество ЕСТЬ, то данная функция его удаляет, 
                        # если НЕТ, то программа пропускает данную строку кода и ошибки не возникает
print(colors)           # Вывод: {'green', 'blue','gray'}

colors.clear()          # Данная функция удаляет все элементы из нашего множества
print(colors)           # Вывод: set() - т.е. пустое множество
print()

# ~~~~~~~~Операции со множествами в Python:
a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21}
# Во множестве "С" копируется все множество "А":
c = a.copy()                                # Результат: c = {1, 2, 3, 5, 8}

# Во множестве "U" объединяются множества "А" и "В", 
# если элементы повторяются, то сохраняется только один элемент:
u = a.union(b)                              # Результат: u = {1, 2, 3, 5, 8, 13, 21}

# Находим пересечение множеств "А" и "В",
# во множество "I" записываем только те элементы, которые содержатся в обоих множествах "А" и "В": 
i = a.intersection(b)                       # Результат: i = {8, 2, 5}

# Находим разность множеств "А" - "В" (из А - все элементы В, и записываем то, что осталось в А):
dl = a.difference(b)                        # Результат: dl = {1, 3}

# Находим разность множеств "В" - "А"(из В - все элементы А, и записываем то, что осталось в В):
dr = b.difference(a)                        # Результат: dr = {13, 21}


q = a.union(b).difference(a.intersection(b))  # Результат: {1, 21, 3, 13}
# Действие 1: (a.intersection(b)) - Находим пересечение множеств "А" и "В"
# Действие 2: a.union(b) - Объединяем множества "А" и "В"
# Действие 3 (.difference), т.е. Действие 3 = Действие 2 - Действие 1
print()

# Неизменяемое или замороженное множество(frozenset) — множество, 
# с которым не будут работать методы удаления и добавления.
a = {1, 2, 3, 5, 8}
b = frozenset(a) # хотим "заморозить" множество "а", т.е. мы никаким образом не сможем его изменить
print(b) # Вывод: frozenset({1, 2, 3, 5, 8})
print()

# ======================= 7. List Comprehension «генератор списков»: =============================
print("======================= 7. List Comprehension «генератор списка»: =============================")
# List comprehension — это упрощенный подход к созданию списка, который задействует цикл for, 
# а также инструкции if-else для определения того, что в итоге окажется в финальном списке.

        ## 1. Простая ситуация — список:
list_1 = [exp for item in iterable]
# создаем какое-то значение(exp) ДЛЯ какого-то списка(item) ПО какой-то коллекции данных(iterable)
list_1 = [NONE for item in range(5)]
# Запись цикла означает, что мы 5 раз(range(5)) добавим в наш список(item) значение(NONE)

        ## 2. Выборка по заданному условию (if conditional):
list_1 = [exp for item in iterable (if conditional)]
print()

# ======================= 7.1. ЗАДАЧА: ====================
print("======================= 7.1. ЗАДАЧА: ====================")
# Создать список, состоящий из четных чисел в диапазоне от 1 до 100.
# Решение:
        ## 1. Создать список чисел от 1 до 100
list_1 = [] # Создаем пустой список
for i in range(1, 101):
    list_1.append(i)
print(list_1)                        # Вывод: [1, 2, 3,..., 100]
print()
#Эту же функцию можно записать так:
list_1 = [i for i in range(1, 101)]  # Результат: [1, 2, 3,..., 100]
print()

        ## 2. Добавить условие (только чётные числа)
list_1 = [i for i in range(1, 101) if i % 2 == 0]       # Результат: [2, 4, 6,..., 100]
# Допустим, вы решили создать пары каждому из чисел (кортежи)
list_1 = [(i, i) for i in range(1, 101) if i % 2 == 0]  # Результат: [(2, 2), (4, 4),..., (100, 100)]
# Также можно умножать, делить, прибавлять, вычитать. Например, умножить значение на 2.
list_1 = [i * 2 for i in range(10) if i % 2 == 0]
print(list_1)                                           # Вывод: [0, 4, 8, 12, 16]
print()

# ======================= 8. ПРОФИЛИРОВАНИЕ И ОТЛАДКА (проверка на ошибки) ====================
print("======================= 8. ПРОФИЛИРОВАНИЕ И ОТЛАДКА (проверка на ошибки) ====================")

# Самые распространенные ошибки
    ## SyntaxError(Синтаксическая ошибка):
number_first = 5
number_second = 7
if number_first > number_second # !!!!!
    print(number_first)
# Ошибка говорит об отсутствии знака :
# Должно быть так:
if number_first > number_second:
    print(number_first)

    ## IndentationError(Ошибка отступов)
number_first = 5
number_second = 7
if number_first > number_second:
print(number_first) # !!!!!
# Ошибка говорит об отсутствие отступов
# Должно быть так:
if number_first > number_second:
    print(number_first)

    ## TypeError(Типовая ошибка)
text = 'Python'
number = 5
print(text + number)
# Ошибка говорит о  том, что нельзя складывать строки и числа

    ## ZeroDivisionError(Деление на 0)
number_first = 5
number_second = 0
print(number_first // number_second)
# Ошибка говорит о  том, что делить на 0 нельзя

    ## KeyError(Ошибка ключа)
dictionary = {1: 'Monday', 2: 'Tuesday'}
print(dictionary[3])
# Ошибка говорит о  том, что такого ключа не существует

    ## NameError(Ошибка имени переменной)
name = 'Ivan'
print(names)
# Ошибка говорит о  том, что переменной names не существует, но есть name

    ## ValueError(Ошибка значения)
text = 'Python'
print(int(text))
# Ошибка говорит о  том, что нельзя символы перевести в целые значения